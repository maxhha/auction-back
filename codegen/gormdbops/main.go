package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

var baseTemplate = template.Must(template.New("baseTemplate").Parse(`
// This file was generated by gormdbopsgen. DO NOT EDIT.
package database

import (
	"auction-back/ports"
	"auction-back/models"
	"fmt"
{{
	range $import, $i := .Imports 
}}	"{{ $import }}"
{{ end 
}})

type {{ .Database }} struct{ *Database }

func (d *Database) {{ .Model }}() ports.{{ .DatabasePort }} { return &{{ .Database }}{d} }
`))

var operationToTemplate = map[string]*template.Template{
	"Get": template.Must(template.New("getTemplate").Parse(`
func (d *{{ .Database }}) Get(id string) (models.{{ .Model }}, error) {
	obj := {{ .Model }}{}
	if err := d.db.Take(&obj, "id = ?", id).Error; err != nil {
		return models.{{ .Model }}{}, fmt.Errorf("take: %w", convertError(err))
	}

	return obj.into(), nil
}
`)),
	"Create": template.Must(template.New("createTemplate").Parse(`
func (d *{{ .Database }}) Create({{ .Entity }} *models.{{ .Model }}) error {
	if {{ .Entity }} == nil {
		return ports.Err{{ .Model }}IsNil
	}
	obj := {{ .Model }}{}
	obj.copy({{ .Entity }})
	if err := d.db.Create(&obj).Error; err != nil {
		return fmt.Errorf("create: %w", convertError(err))
	}

	*{{ .Entity }} = obj.into()
	return nil
}
`)),
	"Pagination": template.Must(template.New("paginationTemplate").Parse(`
func (d *{{ .Database }}) Pagination(first *int, after *string, filter *models.{{ .Model }}sFilter) (models.{{ .Model }}sConnection, error) {
	query := d.filter(d.db.Model(&{{ .Model }}{}), filter)
	query, err := paginationQueryByCreatedAtDesc(query, first, after)
	if err != nil {
		return models.{{ .Model }}sConnection{}, fmt.Errorf("pagination: %w", err)
	}

	var objs []{{ .Model }}
	if err := query.Find(&objs).Error; err != nil {
		return models.{{ .Model }}sConnection{}, fmt.Errorf("find: %w", err)
	}

	if len(objs) == 0 {
		return models.{{ .Model }}sConnection{
			PageInfo: &models.PageInfo{},
			Edges:    make([]*models.{{ .Model }}sConnectionEdge, 0),
		}, nil
	}

	hasNextPage := false

	if first != nil {
		hasNextPage = len(objs) > *first
		objs = objs[:len(objs)-1]
	}

	edges := make([]*models.{{ .Model }}sConnectionEdge, 0, len(objs))

	for _, obj := range objs {
		node := obj.into()

		edges = append(edges, &models.{{ .Model }}sConnectionEdge{
			Cursor: fmt.Sprintf("%v", node.ID),
			Node:   &node,
		})
	}

	startCursor := fmt.Sprintf("%v", objs[0].ID)
	endCursor := fmt.Sprintf("%v", objs[len(objs)-1].ID)

	return models.{{ .Model }}sConnection{
		PageInfo: &models.PageInfo{
			HasNextPage: hasNextPage,
			StartCursor: &startCursor,
			EndCursor:   &endCursor,
		},
		Edges: edges,
	}, nil
}
`)),
	"Take": template.Must(template.New("takeTemplate").Parse(`
func (d *{{ .Database }}) Take(config ports.{{ .Model }}TakeConfig) (models.{{ .Model }}, error) {
	query := d.filter(d.db, config.Filter)

	obj := {{ .Model }}{}
	if err := query.Take(&obj).Error; err != nil {
		return models.{{ .Model }}{}, fmt.Errorf("take: %w", convertError(err))
	}

	return obj.into(), nil
}
`)),
	"Update": template.Must(template.New("updateTemplate").Parse(`
func (d *{{ .Database }}) Update({{ .Entity }} *models.{{ .Model }}) error {
	if {{ .Entity }} == nil {
		return ports.Err{{ .Model }}IsNil
	}

	obj := {{ .Model }}{}
	obj.copy({{ .Entity }})

	if err := d.db.Save(&obj).Error; err != nil {
		return fmt.Errorf("save: %w", convertError(err))
	}
	*{{ .Entity }} = obj.into()

	return nil
}
`)),
}

var methodsOrder = []string{
	"Get",
	"Take",
	"Create",
	"Update",
	"Pagination",
}

var methodToImports = map[string][]string{}

type Config struct {
	Database     string
	DatabasePort string
	Model        string
	Entity       string
	Methods      map[string]struct{}
	Imports      map[string]struct{}
}

func (config *Config) Generate(out io.Writer) {
	if err := baseTemplate.Execute(out, config); err != nil {
		log.Fatalf("baseTemplate.Execute: %v", err)
	}

	for _, m := range methodsOrder {
		if _, exists := config.Methods[m]; !exists {
			continue
		}

		if err := operationToTemplate[m].Execute(out, config); err != nil {
			log.Fatalf("operationToTemplate[%s].Execute: %v", m, err)
		}
	}
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

func main() {
	fileout := flag.String("out", "", "output file")
	model := flag.String("model", "", "model name")
	methods := flag.String("methods", "", "methods list")
	flag.Parse()

	out, err := os.Create(*fileout)
	if err != nil {
		log.Fatalf("create file: %v", err)
	}

	methodsSet := make(map[string]struct{})
	for _, m := range strings.Split(*methods, ",") {
		if _, exists := operationToTemplate[m]; !exists {
			log.Fatalf("unknown method: %s", m)
		}
		methodsSet[m] = struct{}{}
	}

	imports := make(map[string]struct{})
	for m := range methodsSet {
		imps, exists := methodToImports[m]
		if !exists {
			continue
		}
		for _, i := range imps {
			imports[i] = struct{}{}
		}
	}

	entity := lowerFirst(*model)
	db := fmt.Sprintf("%sDB", entity)

	config := Config{
		Database:     db,
		Entity:       entity,
		Model:        *model,
		DatabasePort: strings.Title(db),
		Methods:      methodsSet,
		Imports:      imports,
	}

	var buf bytes.Buffer
	config.Generate(&buf)

	p, err := format.Source(buf.Bytes())

	if err != nil {
		log.Fatalf("format error: %v", err)
	}
	out.Write(p)
	out.Close()
	fmt.Printf("%s[%s] -> %s\n", *model, *methods, *fileout)
}
